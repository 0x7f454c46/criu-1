#ifndef __CR_PROTOBUF_DEFS_H__
#define __CR_PROTOBUF_DEFS_H__

#include <google/protobuf-c/protobuf-c.h>

enum {
	PB_INVENTORY,
	PB_FDINFO,
	PB_CORE,
	PB_MM,
	PB_VMAS,
	PB_SIGACT,
	PB_ITIMERS,
	PB_CREDS,
	PB_FS,
	PB_UTSNS,
	PB_IPCNS_VAR,
	PB_IPCNS_SHM,
	PB_IPCNS_MSG,
	PB_IPCNS_MSG_ENT,
	PB_IPCNS_SEM,
	PB_MOUNTPOINTS,
	PB_NETDEV,
	PB_PSTREE,
	PB_GHOST_FILE,
	PB_TCP_STREAM,
	PB_SK_QUEUES,
	PB_REG_FILES,
	PB_INETSK,
	PB_UNIXSK,
	PB_PACKETSK,
	PB_NETLINKSK,
	PB_PIPES,
	PB_FIFO,
	PB_PIPES_DATA,
	PB_REMAP_FPATH,
	PB_EVENTFD,
	PB_EVENTPOLL,
	PB_EVENTPOLL_TFD,
	PB_SIGNALFD,
	PB_INOTIFY,
	PB_INOTIFY_WD,
	PB_FANOTIFY,
	PB_FANOTIFY_MARK,
	PB_TTY,
	PB_TTY_INFO,
	PB_FILE_LOCK,
	PB_RLIMIT,
	PB_IDS,
	PB_PAGEMAP_HEAD,
	PB_PAGEMAP,
	PB_SIGINFO,

	PB_MAX
};

/*
 * ATTENTION
 *
 * This typdefs represent "generic" prototypes for
 * pack/unpack/getsize functions generated by PB
 * engine, thus (!!!) if PB engine change arguments
 * order or their number we may meet serious problems.
 *
 * FIXME
 *
 * Find a way to verify PB generated functions statemens
 * to match this typedefs.
 */

typedef size_t (*pb_getpksize_t)(void *obj);
typedef size_t (*pb_pack_t)(void *obj, void *where);
typedef void  *(*pb_unpack_t)(void *allocator, size_t size, void *from);
typedef void   (*pb_free_t)(void *obj, void *allocator);

struct cr_pb_message_desc {
	pb_getpksize_t				getpksize;
	pb_pack_t				pack;
	pb_unpack_t				unpack;
	pb_free_t				free;
	const ProtobufCMessageDescriptor	*pb_desc;
};

#define PB_PACK_TYPECHECK(__o, __fn)	({ if (0) __fn##__pack(__o, NULL); (pb_pack_t)&__fn##__pack; })
#define PB_GPS_TYPECHECK(__o, __fn)	({ if (0) __fn##__get_packed_size(__o); (pb_getpksize_t)&__fn##__get_packed_size; })
#define PB_UNPACK_TYPECHECK(__op, __fn)	({ if (0) *__op = __fn##__unpack(NULL, 0, NULL); (pb_unpack_t)&__fn##__unpack; })
#define PB_FREE_TYPECHECK(__o, __fn)	({ if (0) __fn##__free_unpacked(__o, NULL); (pb_free_t)&__fn##__free_unpacked; })

/*
 * This should be explicitly "called" to do type-checking
 */

#ifndef CR_PB_MDESC_INIT
#define CR_PB_MDESC_INIT(__var, __type, __name)					\
	do {									\
		__var.getpksize	= PB_GPS_TYPECHECK((__type *)NULL, __name);	\
		__var.pack	= PB_PACK_TYPECHECK((__type *)NULL, __name);	\
		__var.unpack	= PB_UNPACK_TYPECHECK((__type **)NULL, __name);	\
		__var.free	= PB_FREE_TYPECHECK((__type *)NULL, __name);	\
		__var.pb_desc	= &__name##__descriptor;			\
	} while (0)
#endif

#ifndef CR_PB_DESC
#define CR_PB_DESC(__type, __vtype, __ftype)					\
	CR_PB_MDESC_INIT(cr_pb_descs[PB_##__type],				\
			 __vtype##Entry, __ftype##_entry)
#endif

extern struct cr_pb_message_desc cr_pb_descs[PB_MAX];
extern void cr_pb_init(void);

#define pb_pksize(__obj, __proto_message_name)					\
	(__proto_message_name ##__get_packed_size(__obj) + sizeof(u32))

#define pb_repeated_size(__obj, __member)					\
	((size_t)(sizeof(*(__obj)->__member) * (__obj)->n_ ##__member))

#define pb_msg(__base, __type)							\
	container_of(__base, __type, base)

#endif /* __CR_PROTOBUF_DEFS_H__ */
